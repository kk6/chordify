name: Project Board Automation

on:
  pull_request:
    types: [opened, closed]
  issues:
    types: [assigned, labeled, opened]

jobs:
  project_automation:
    runs-on: ubuntu-latest
    steps:
      - name: Automate Project Status
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const projectId = "PVT_kwHOAAkYos4A1Ltq";
            const statusFieldId = "PVTSSF_lAHOAAkYos4A1Ltqzgqsc9s";
            const STATUS = {
              BACKLOG: "f75ad846",
              READY: "61e4505c",
              IN_PROGRESS: "47fc9ee4",
              IN_REVIEW: "df73e18b",
              DONE: "98236657"
            };

            async function getProjectItemId(issueNumber) {
              let items = [];
              let hasNextPage = true;
              let endCursor = null;

              while (hasNextPage) {
                const result = await github.graphql(`
                  query($projectId: ID!, $after: String) {
                    node(id: $projectId) {
                      ... on ProjectV2 {
                        items(first: 100, after: $after) {
                          nodes {
                            id
                            content {
                              ... on Issue {
                                number
                              }
                            }
                          }
                          pageInfo {
                            hasNextPage
                            endCursor
                          }
                        }
                      }
                    }
                  }
                }
              `, { projectId });

              return result.node.items.nodes.find(i => i.content?.number === issueNumber)?.id || null;
            }

            async function updateStatus(issueNumber, statusId) {
              const itemId = await getProjectItemId(issueNumber);
              if (!itemId) {
                console.log(`❌ Issue #${issueNumber} not found in project.`);
                return;
              }

              try {
                await github.graphql(`
                  mutation($input: UpdateProjectV2ItemFieldValueInput!) {
                    updateProjectV2ItemFieldValue(input: $input) {
                      projectV2Item {
                        id
                      }
                    }
                  }
                `, {
                  input: {
                    projectId,
                    itemId,
                    fieldId: statusFieldId,
                    value: {
                      singleSelectOptionId: statusId
                    }
                  }
                });

                console.log(`✅ Updated issue #${issueNumber} status.`);
              } catch (error) {
                console.log(`❌ Failed to update status for issue #${issueNumber}: ${error.message}`);
              }
            }

            async function addIssueToProject(issueNodeId) {
              await github.graphql(`
                mutation($input: AddProjectV2ItemByIdInput!) {
                  addProjectV2ItemById(input: $input) {
                    item {
                      id
                    }
                  }
                }
              `, {
                input: {
                  projectId,
                  contentId: issueNodeId
                }
              });

              console.log(`✅ Issue added to project.`);
            }

            const event = context.eventName;

            if (event === "pull_request") {
              const pr = context.payload.pull_request;
              const timeline = await github.rest.issues.listEventsForTimeline({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                mediaType: { previews: ['mockingbird'] }
              });

              for (const event of timeline.data) {
                const issue = event.source?.issue;
                if (event.event === 'cross-referenced' && issue && !issue.pull_request) {
                  if (context.payload.action === 'closed' && pr.merged) {
                    await updateStatus(issue.number, STATUS.DONE);
                  } else if (context.payload.action === 'opened') {
                    await updateStatus(issue.number, STATUS.IN_REVIEW);
                  }
                }
              }
            }

            if (event === "issues") {
              const issue = context.payload.issue;

              // Issue作成時にプロジェクトへ追加
              if (context.payload.action === "opened") {
                await addIssueToProject(issue.node_id);
              }

              // AssigneeがついたらIn progressへ
              if (context.payload.action === "assigned") {
                await updateStatus(issue.number, STATUS.IN_PROGRESS);
              }

              // ラベルによる自動ステータス変更
              if (context.payload.action === "labeled") {
                const label = context.payload.label.name.toLowerCase();

                if (label === "ready" || label === "high") {
                  await updateStatus(issue.number, STATUS.READY);
                } else if (label === "blocked") {
                  await updateStatus(issue.number, STATUS.BACKLOG);
                }
              }
            }
